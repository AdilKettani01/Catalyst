// AUTO-GENERATED Catalyst translation scaffold.
// Source: animations/VID/_2022/visual_proofs/lies.py
//
// This is a stub port from Manim (Python) to Catalyst (C++).
// Fill in each scene function and replace TODOs with real Catalyst calls.

#include <Catalyst>
#include <cstdint>
#include <cstring>
#include <string_view>

namespace {
constexpr uint32_t kWidth = 1920;
constexpr uint32_t kHeight = 1080;
constexpr float kManimFrameHeight = 8.0f;
constexpr float kManimUnit = static_cast<float>(kHeight) / kManimFrameHeight;  // px per Manim unit

constexpr float X(float manimX) { return static_cast<float>(kWidth) * 0.5f + manimX * kManimUnit; }
constexpr float Y(float manimY) { return static_cast<float>(kHeight) * 0.5f + manimY * kManimUnit; }
}  // namespace

static void PreviewThreeExamples(Catalyst& window) {
    // TODO: Port `PreviewThreeExamples.construct()` (base: InteractiveScene)
    // From: animations/VID/_2022/visual_proofs/lies.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void Intro(Catalyst& window) {
    // TODO: Port `Intro.construct()` (base: TeacherStudentsScene)
    // From: animations/VID/_2022/visual_proofs/lies.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void SimpleSphereQuestion(Catalyst& window) {
    // TODO: Port `SimpleSphereQuestion.construct()` (base: InteractiveScene)
    // From: animations/VID/_2022/visual_proofs/lies.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void SphereExample(Catalyst& window) {
    // TODO: Port `SphereExample.construct()` (base: InteractiveScene)
    // From: animations/VID/_2022/visual_proofs/lies.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void CallOutSphereExampleAsWrong(Catalyst& window) {
    // TODO: Port `CallOutSphereExampleAsWrong.construct()` (base: InteractiveScene)
    // From: animations/VID/_2022/visual_proofs/lies.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void SomethingSomethingLimits(Catalyst& window) {
    // TODO: Port `SomethingSomethingLimits.construct()` (base: TeacherStudentsScene)
    // From: animations/VID/_2022/visual_proofs/lies.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void PiEqualsFourOverlay(Catalyst& window) {
    // TODO: Port `PiEqualsFourOverlay.construct()` (base: InteractiveScene)
    // From: animations/VID/_2022/visual_proofs/lies.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void Proof2Slide(Catalyst& window) {
    // TODO: Port `Proof2Slide.construct()` (base: InteractiveScene)
    // From: animations/VID/_2022/visual_proofs/lies.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void CircleExample(Catalyst& window) {
    // TODO: Port `CircleExample.construct()` (base: InteractiveScene)
    // From: animations/VID/_2022/visual_proofs/lies.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void SideBySide(Catalyst& window) {
    // TODO: Port `SideBySide.construct()` (base: InteractiveScene)
    // From: animations/VID/_2022/visual_proofs/lies.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void SphereSectorAnalysis(Catalyst& window) {
    // TODO: Port `SphereSectorAnalysis.construct()` (base: Scene)
    // From: animations/VID/_2022/visual_proofs/lies.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void FalseVsTrueSurfaceAreaOverlay(Catalyst& window) {
    // TODO: Port `FalseVsTrueSurfaceAreaOverlay.construct()` (base: InteractiveScene)
    // From: animations/VID/_2022/visual_proofs/lies.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void FakeAreaManipulation(Catalyst& window) {
    // TODO: Port `FakeAreaManipulation.construct()` (base: InteractiveScene)
    // From: animations/VID/_2022/visual_proofs/lies.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void ContrastSphericalGeometry(Catalyst& window) {
    // TODO: Port `ContrastSphericalGeometry.construct()` (base: InteractiveScene)
    // From: animations/VID/_2022/visual_proofs/lies.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void GiveItAGo(Catalyst& window) {
    // TODO: Port `GiveItAGo.construct()` (base: TeacherStudentsScene)
    // From: animations/VID/_2022/visual_proofs/lies.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void SquareCircleExample(Catalyst& window) {
    // TODO: Port `SquareCircleExample.construct()` (base: InteractiveScene)
    // From: animations/VID/_2022/visual_proofs/lies.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void ObviouslyWrong(Catalyst& window) {
    // TODO: Port `ObviouslyWrong.construct()` (base: TeacherStudentsScene)
    // From: animations/VID/_2022/visual_proofs/lies.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void UpshotOfLimitExample(Catalyst& window) {
    // TODO: Port `UpshotOfLimitExample.construct()` (base: InteractiveScene)
    // From: animations/VID/_2022/visual_proofs/lies.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void WhyWeNeedProofs(Catalyst& window) {
    // TODO: Port `WhyWeNeedProofs.construct()` (base: TeacherStudentsScene)
    // From: animations/VID/_2022/visual_proofs/lies.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void Proof3Slide(Catalyst& window) {
    // TODO: Port `Proof3Slide.construct()` (base: InteractiveScene)
    // From: animations/VID/_2022/visual_proofs/lies.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void SpeakingOfLimits(Catalyst& window) {
    // TODO: Port `SpeakingOfLimits.construct()` (base: TeacherStudentsScene)
    // From: animations/VID/_2022/visual_proofs/lies.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void IntegralExample(Catalyst& window) {
    // TODO: Port `IntegralExample.construct()` (base: InteractiveScene)
    // From: animations/VID/_2022/visual_proofs/lies.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void IntegralError(Catalyst& window) {
    // TODO: Port `IntegralError.construct()` (base: InteractiveScene)
    // From: animations/VID/_2022/visual_proofs/lies.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void DefiningTheLengthOfACurve(Catalyst& window) {
    // TODO: Port `DefiningTheLengthOfACurve.construct()` (base: InteractiveScene)
    // From: animations/VID/_2022/visual_proofs/lies.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void FalseEuclidProofAnnotation(Catalyst& window) {
    // TODO: Port `FalseEuclidProofAnnotation.construct()` (base: InteractiveScene)
    // From: animations/VID/_2022/visual_proofs/lies.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void FalseEuclidFollowup(Catalyst& window) {
    // TODO: Port `FalseEuclidFollowup.construct()` (base: InteractiveScene)
    // From: animations/VID/_2022/visual_proofs/lies.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void TryToFindFault(Catalyst& window) {
    // TODO: Port `TryToFindFault.construct()` (base: TeacherStudentsScene)
    // From: animations/VID/_2022/visual_proofs/lies.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void SideSumTruthiness(Catalyst& window) {
    // TODO: Port `SideSumTruthiness.construct()` (base: InteractiveScene)
    // From: animations/VID/_2022/visual_proofs/lies.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void PythagoreanProofSketch(Catalyst& window) {
    // TODO: Port `PythagoreanProofSketch.construct()` (base: InteractiveScene)
    // From: animations/VID/_2022/visual_proofs/lies.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void LastSideBySide(Catalyst& window) {
    // TODO: Port `LastSideBySide.construct()` (base: InteractiveScene)
    // From: animations/VID/_2022/visual_proofs/lies.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void ByTheWay(Catalyst& window) {
    // TODO: Port `ByTheWay.construct()` (base: InteractiveScene)
    // From: animations/VID/_2022/visual_proofs/lies.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

struct SceneEntry {
    const char* name;
    void (*fn)(Catalyst&);
};

static constexpr SceneEntry kScenes[] = {
    {"PreviewThreeExamples", &PreviewThreeExamples},
    {"Intro", &Intro},
    {"SimpleSphereQuestion", &SimpleSphereQuestion},
    {"SphereExample", &SphereExample},
    {"CallOutSphereExampleAsWrong", &CallOutSphereExampleAsWrong},
    {"SomethingSomethingLimits", &SomethingSomethingLimits},
    {"PiEqualsFourOverlay", &PiEqualsFourOverlay},
    {"Proof2Slide", &Proof2Slide},
    {"CircleExample", &CircleExample},
    {"SideBySide", &SideBySide},
    {"SphereSectorAnalysis", &SphereSectorAnalysis},
    {"FalseVsTrueSurfaceAreaOverlay", &FalseVsTrueSurfaceAreaOverlay},
    {"FakeAreaManipulation", &FakeAreaManipulation},
    {"ContrastSphericalGeometry", &ContrastSphericalGeometry},
    {"GiveItAGo", &GiveItAGo},
    {"SquareCircleExample", &SquareCircleExample},
    {"ObviouslyWrong", &ObviouslyWrong},
    {"UpshotOfLimitExample", &UpshotOfLimitExample},
    {"WhyWeNeedProofs", &WhyWeNeedProofs},
    {"Proof3Slide", &Proof3Slide},
    {"SpeakingOfLimits", &SpeakingOfLimits},
    {"IntegralExample", &IntegralExample},
    {"IntegralError", &IntegralError},
    {"DefiningTheLengthOfACurve", &DefiningTheLengthOfACurve},
    {"FalseEuclidProofAnnotation", &FalseEuclidProofAnnotation},
    {"FalseEuclidFollowup", &FalseEuclidFollowup},
    {"TryToFindFault", &TryToFindFault},
    {"SideSumTruthiness", &SideSumTruthiness},
    {"PythagoreanProofSketch", &PythagoreanProofSketch},
    {"LastSideBySide", &LastSideBySide},
    {"ByTheWay", &ByTheWay},
};

int main(int argc, char** argv) {
    Catalyst window(kWidth, kHeight);
    window.setBackground("#000000");
    // window.set3DMode(true);

    const char* chosen = (argc >= 2) ? argv[1] : kScenes[0].name;
    for (const auto& s : kScenes) {
        if (std::strcmp(s.name, chosen) == 0) {
            s.fn(window);
            window.run();
            return 0;
        }
    }

    // Unknown scene name; run the first scene.
    kScenes[0].fn(window);
    window.run();
    return 0;
}
