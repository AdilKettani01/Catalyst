// AUTO-GENERATED Catalyst translation scaffold.
// Source: animations/VID/_2022/_2020/chess.py
//
// This is a stub port from Manim (Python) to Catalyst (C++).
// Fill in each scene function and replace TODOs with real Catalyst calls.

#include <Catalyst>
#include <cstdint>
#include <cstring>
#include <string_view>

namespace {
constexpr uint32_t kWidth = 1920;
constexpr uint32_t kHeight = 1080;
constexpr float kManimFrameHeight = 8.0f;
constexpr float kManimUnit = static_cast<float>(kHeight) / kManimFrameHeight;  // px per Manim unit

constexpr float X(float manimX) { return static_cast<float>(kWidth) * 0.5f + manimX * kManimUnit; }
constexpr float Y(float manimY) { return static_cast<float>(kHeight) * 0.5f + manimY * kManimUnit; }
}  // namespace

static void IntroducePuzzle(Catalyst& window) {
    // TODO: Port `IntroducePuzzle.construct()` (base: Scene)
    // From: animations/VID/_2022/_2020/chess.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void PrisonerPuzzleSetting(Catalyst& window) {
    // TODO: Port `PrisonerPuzzleSetting.construct()` (base: PiCreatureScene)
    // From: animations/VID/_2022/_2020/chess.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void FromCoinToSquareMaps(Catalyst& window) {
    // TODO: Port `FromCoinToSquareMaps.construct()` (base: ThreeDScene)
    // From: animations/VID/_2022/_2020/chess.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void DiagramOfProgression(Catalyst& window) {
    // TODO: Port `DiagramOfProgression.construct()` (base: ThreeDScene)
    // From: animations/VID/_2022/_2020/chess.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void ErrorCorrectionMention(Catalyst& window) {
    // TODO: Port `ErrorCorrectionMention.construct()` (base: Scene)
    // From: animations/VID/_2022/_2020/chess.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void StandupMathsWrapper(Catalyst& window) {
    // TODO: Port `StandupMathsWrapper.construct()` (base: Scene)
    // From: animations/VID/_2022/_2020/chess.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void TitleCard(Catalyst& window) {
    // TODO: Port `TitleCard.construct()` (base: Scene)
    // From: animations/VID/_2022/_2020/chess.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void WhatAreWeDoingHere(Catalyst& window) {
    // TODO: Port `WhatAreWeDoingHere.construct()` (base: TeacherStudentsScene)
    // From: animations/VID/_2022/_2020/chess.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void HowCanWeVisualizeSolutions(Catalyst& window) {
    // TODO: Port `HowCanWeVisualizeSolutions.construct()` (base: TeacherStudentsScene)
    // From: animations/VID/_2022/_2020/chess.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void TwoSquareCase(Catalyst& window) {
    // TODO: Port `TwoSquareCase.construct()` (base: ThreeDScene)
    // From: animations/VID/_2022/_2020/chess.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void IGotThis(Catalyst& window) {
    // TODO: Port `IGotThis.construct()` (base: TeacherStudentsScene)
    // From: animations/VID/_2022/_2020/chess.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void WalkingTheSquare(Catalyst& window) {
    // TODO: Port `WalkingTheSquare.construct()` (base: ThreeDScene)
    // From: animations/VID/_2022/_2020/chess.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void ThreeSquareCase(Catalyst& window) {
    // TODO: Port `ThreeSquareCase.construct()` (base: ThreeDScene)
    // From: animations/VID/_2022/_2020/chess.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void FailedMod3Addition(Catalyst& window) {
    // TODO: Port `FailedMod3Addition.construct()` (base: Scene)
    // From: animations/VID/_2022/_2020/chess.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void TreeOfThreeFlips(Catalyst& window) {
    // TODO: Port `TreeOfThreeFlips.construct()` (base: ThreeDScene)
    // From: animations/VID/_2022/_2020/chess.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void SeventyFivePercentChance(Catalyst& window) {
    // TODO: Port `SeventyFivePercentChance.construct()` (base: Scene)
    // From: animations/VID/_2022/_2020/chess.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void ModNStrategy(Catalyst& window) {
    // TODO: Port `ModNStrategy.construct()` (base: ThreeDScene)
    // From: animations/VID/_2022/_2020/chess.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void ShowCube(Catalyst& window) {
    // TODO: Port `ShowCube.construct()` (base: ThreeDScene)
    // From: animations/VID/_2022/_2020/chess.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void CubeSupplement(Catalyst& window) {
    // TODO: Port `CubeSupplement.construct()` (base: ThreeDScene)
    // From: animations/VID/_2022/_2020/chess.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void CubeEdgeDescription(Catalyst& window) {
    // TODO: Port `CubeEdgeDescription.construct()` (base: Scene)
    // From: animations/VID/_2022/_2020/chess.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void EdgeColoringExample(Catalyst& window) {
    // TODO: Port `EdgeColoringExample.construct()` (base: Scene)
    // From: animations/VID/_2022/_2020/chess.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void GrahamsConstantAlt(Catalyst& window) {
    // TODO: Port `GrahamsConstantAlt.construct()` (base: Scene)
    // From: animations/VID/_2022/_2020/chess.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void ThinkAboutNewTrick(Catalyst& window) {
    // TODO: Port `ThinkAboutNewTrick.construct()` (base: PiCreatureScene)
    // From: animations/VID/_2022/_2020/chess.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void AttemptAColoring(Catalyst& window) {
    // TODO: Port `AttemptAColoring.construct()` (base: ThreeDScene)
    // From: animations/VID/_2022/_2020/chess.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void TryTheProofYourself(Catalyst& window) {
    // TODO: Port `TryTheProofYourself.construct()` (base: TeacherStudentsScene)
    // From: animations/VID/_2022/_2020/chess.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void HighDimensionalCount(Catalyst& window) {
    // TODO: Port `HighDimensionalCount.construct()` (base: ThreeDScene)
    // From: animations/VID/_2022/_2020/chess.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void SimpleRect(Catalyst& window) {
    // TODO: Port `SimpleRect.construct()` (base: Scene)
    // From: animations/VID/_2022/_2020/chess.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void WhenIsItHopeless(Catalyst& window) {
    // TODO: Port `WhenIsItHopeless.construct()` (base: Scene)
    // From: animations/VID/_2022/_2020/chess.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void FourDCubeColoringFromTrees(Catalyst& window) {
    // TODO: Port `FourDCubeColoringFromTrees.construct()` (base: ThreeDScene)
    // From: animations/VID/_2022/_2020/chess.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void WantAdditionToBeSubtraction(Catalyst& window) {
    // TODO: Port `WantAdditionToBeSubtraction.construct()` (base: ThreeDScene)
    // From: animations/VID/_2022/_2020/chess.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void BitVectorSum(Catalyst& window) {
    // TODO: Port `BitVectorSum.construct()` (base: ThreeDScene)
    // From: animations/VID/_2022/_2020/chess.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void ExampleSquareAsBinaryNumber(Catalyst& window) {
    // TODO: Port `ExampleSquareAsBinaryNumber.construct()` (base: Scene)
    // From: animations/VID/_2022/_2020/chess.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void SkipSkipYesYes(Catalyst& window) {
    // TODO: Port `SkipSkipYesYes.construct()` (base: Scene)
    // From: animations/VID/_2022/_2020/chess.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void ShowCurrAndTarget(Catalyst& window) {
    // TODO: Port `ShowCurrAndTarget.construct()` (base: Scene)
    // From: animations/VID/_2022/_2020/chess.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void EulerDiagram(Catalyst& window) {
    // TODO: Port `EulerDiagram.construct()` (base: Scene)
    // From: animations/VID/_2022/_2020/chess.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void ShowBoardRegions(Catalyst& window) {
    // TODO: Port `ShowBoardRegions.construct()` (base: ThreeDScene)
    // From: animations/VID/_2022/_2020/chess.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void ShowFinalStrategy(Catalyst& window) {
    // TODO: Port `ShowFinalStrategy.construct()` (base: Scene)
    // From: animations/VID/_2022/_2020/chess.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

struct SceneEntry {
    const char* name;
    void (*fn)(Catalyst&);
};

static constexpr SceneEntry kScenes[] = {
    {"IntroducePuzzle", &IntroducePuzzle},
    {"PrisonerPuzzleSetting", &PrisonerPuzzleSetting},
    {"FromCoinToSquareMaps", &FromCoinToSquareMaps},
    {"DiagramOfProgression", &DiagramOfProgression},
    {"ErrorCorrectionMention", &ErrorCorrectionMention},
    {"StandupMathsWrapper", &StandupMathsWrapper},
    {"TitleCard", &TitleCard},
    {"WhatAreWeDoingHere", &WhatAreWeDoingHere},
    {"HowCanWeVisualizeSolutions", &HowCanWeVisualizeSolutions},
    {"TwoSquareCase", &TwoSquareCase},
    {"IGotThis", &IGotThis},
    {"WalkingTheSquare", &WalkingTheSquare},
    {"ThreeSquareCase", &ThreeSquareCase},
    {"FailedMod3Addition", &FailedMod3Addition},
    {"TreeOfThreeFlips", &TreeOfThreeFlips},
    {"SeventyFivePercentChance", &SeventyFivePercentChance},
    {"ModNStrategy", &ModNStrategy},
    {"ShowCube", &ShowCube},
    {"CubeSupplement", &CubeSupplement},
    {"CubeEdgeDescription", &CubeEdgeDescription},
    {"EdgeColoringExample", &EdgeColoringExample},
    {"GrahamsConstantAlt", &GrahamsConstantAlt},
    {"ThinkAboutNewTrick", &ThinkAboutNewTrick},
    {"AttemptAColoring", &AttemptAColoring},
    {"TryTheProofYourself", &TryTheProofYourself},
    {"HighDimensionalCount", &HighDimensionalCount},
    {"SimpleRect", &SimpleRect},
    {"WhenIsItHopeless", &WhenIsItHopeless},
    {"FourDCubeColoringFromTrees", &FourDCubeColoringFromTrees},
    {"WantAdditionToBeSubtraction", &WantAdditionToBeSubtraction},
    {"BitVectorSum", &BitVectorSum},
    {"ExampleSquareAsBinaryNumber", &ExampleSquareAsBinaryNumber},
    {"SkipSkipYesYes", &SkipSkipYesYes},
    {"ShowCurrAndTarget", &ShowCurrAndTarget},
    {"EulerDiagram", &EulerDiagram},
    {"ShowBoardRegions", &ShowBoardRegions},
    {"ShowFinalStrategy", &ShowFinalStrategy},
};

int main(int argc, char** argv) {
    Catalyst window(kWidth, kHeight);
    window.setBackground("#000000");
    // window.set3DMode(true);

    const char* chosen = (argc >= 2) ? argv[1] : kScenes[0].name;
    for (const auto& s : kScenes) {
        if (std::strcmp(s.name, chosen) == 0) {
            s.fn(window);
            window.run();
            return 0;
        }
    }

    // Unknown scene name; run the first scene.
    kScenes[0].fn(window);
    window.run();
    return 0;
}
