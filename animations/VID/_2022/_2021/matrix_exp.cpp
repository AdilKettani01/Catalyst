// AUTO-GENERATED Catalyst translation scaffold.
// Source: animations/VID/_2022/_2021/matrix_exp.py
//
// This is a stub port from Manim (Python) to Catalyst (C++).
// Fill in each scene function and replace TODOs with real Catalyst calls.

#include <Catalyst>
#include <cstdint>
#include <cstring>
#include <string_view>

namespace {
constexpr uint32_t kWidth = 1920;
constexpr uint32_t kHeight = 1080;
constexpr float kManimFrameHeight = 8.0f;
constexpr float kManimUnit = static_cast<float>(kHeight) / kManimFrameHeight;  // px per Manim unit

constexpr float X(float manimX) { return static_cast<float>(kWidth) * 0.5f + manimX * kManimUnit; }
constexpr float Y(float manimY) { return static_cast<float>(kHeight) * 0.5f + manimY * kManimUnit; }
}  // namespace

static void VideoWrapper(Catalyst& window) {
    // TODO: Port `VideoWrapper.construct()` (base: Scene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void ArnoldBookClip(Catalyst& window) {
    // TODO: Port `ArnoldBookClip.construct()` (base: ExternallyAnimatedScene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void ZoomInOnProblem(Catalyst& window) {
    // TODO: Port `ZoomInOnProblem.construct()` (base: Scene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void LeadToPhysicsAndQM(Catalyst& window) {
    // TODO: Port `LeadToPhysicsAndQM.construct()` (base: Scene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void PlanForThisVideo(Catalyst& window) {
    // TODO: Port `PlanForThisVideo.construct()` (base: TeacherStudentsScene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void IntroduceTheComputation(Catalyst& window) {
    // TODO: Port `IntroduceTheComputation.construct()` (base: Scene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void WhyTortureMatrices(Catalyst& window) {
    // TODO: Port `WhyTortureMatrices.construct()` (base: TeacherStudentsScene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void DefinitionFirstVsLast(Catalyst& window) {
    // TODO: Port `DefinitionFirstVsLast.construct()` (base: Scene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void RomeoAndJuliet(Catalyst& window) {
    // TODO: Port `RomeoAndJuliet.construct()` (base: Scene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void DiscussSystem(Catalyst& window) {
    // TODO: Port `DiscussSystem.construct()` (base: Scene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void MoreGeneralSystem(Catalyst& window) {
    // TODO: Port `MoreGeneralSystem.construct()` (base: Scene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void HowExampleLeadsToMatrixExponents(Catalyst& window) {
    // TODO: Port `HowExampleLeadsToMatrixExponents.construct()` (base: Scene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void From2DTo1D(Catalyst& window) {
    // TODO: Port `From2DTo1D.construct()` (base: Scene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void SchroedingersEquationIntro(Catalyst& window) {
    // TODO: Port `SchroedingersEquationIntro.construct()` (base: Scene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void SimpleDerivativeOfExp(Catalyst& window) {
    // TODO: Port `SimpleDerivativeOfExp.construct()` (base: TeacherStudentsScene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void ETitleCard(Catalyst& window) {
    // TODO: Port `ETitleCard.construct()` (base: Scene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void GraphAndHistoryOfExponential(Catalyst& window) {
    // TODO: Port `GraphAndHistoryOfExponential.construct()` (base: Scene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void BernoullisThoughts(Catalyst& window) {
    // TODO: Port `BernoullisThoughts.construct()` (base: Scene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void CompoundInterestPopulationAndEpidemic(Catalyst& window) {
    // TODO: Port `CompoundInterestPopulationAndEpidemic.construct()` (base: Scene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void CovidPlot(Catalyst& window) {
    // TODO: Port `CovidPlot.construct()` (base: ExternallyAnimatedScene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void Compare1DTo2DEquations(Catalyst& window) {
    // TODO: Port `Compare1DTo2DEquations.construct()` (base: Scene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void ManyExponentialForms(Catalyst& window) {
    // TODO: Port `ManyExponentialForms.construct()` (base: ExternallyAnimatedScene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void EBaseMisconception(Catalyst& window) {
    // TODO: Port `EBaseMisconception.construct()` (base: Scene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void OneFinalPoint(Catalyst& window) {
    // TODO: Port `OneFinalPoint.construct()` (base: TeacherStudentsScene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void ExoticExponentsWithEBase(Catalyst& window) {
    // TODO: Port `ExoticExponentsWithEBase.construct()` (base: Scene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void TryToDefineExp(Catalyst& window) {
    // TODO: Port `TryToDefineExp.construct()` (base: TeacherStudentsScene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void SolutionToRomeoJuliet(Catalyst& window) {
    // TODO: Port `SolutionToRomeoJuliet.construct()` (base: Scene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void RotMatrixStill(Catalyst& window) {
    // TODO: Port `RotMatrixStill.construct()` (base: Scene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void ExpRotMatrixComputation(Catalyst& window) {
    // TODO: Port `ExpRotMatrixComputation.construct()` (base: Scene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void ThatsHorrifying(Catalyst& window) {
    // TODO: Port `ThatsHorrifying.construct()` (base: TeacherStudentsScene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void HowBasisVectorMultiplicationPullsOutColumns(Catalyst& window) {
    // TODO: Port `HowBasisVectorMultiplicationPullsOutColumns.construct()` (base: Scene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void ColumnsToBasisVectors(Catalyst& window) {
    // TODO: Port `ColumnsToBasisVectors.construct()` (base: ExternallyAnimatedScene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void ReadColumnsOfRotationMatrix(Catalyst& window) {
    // TODO: Port `ReadColumnsOfRotationMatrix.construct()` (base: Scene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void Show90DegreeRotation(Catalyst& window) {
    // TODO: Port `Show90DegreeRotation.construct()` (base: Scene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void Show90DegreeRotationColumnByColumn(Catalyst& window) {
    // TODO: Port `Show90DegreeRotationColumnByColumn.construct()` (base: Scene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void DistanceOverTimeEquation(Catalyst& window) {
    // TODO: Port `DistanceOverTimeEquation.construct()` (base: Scene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void ExplicitSolution(Catalyst& window) {
    // TODO: Port `ExplicitSolution.construct()` (base: Scene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void TwoDifferetViewsWrapper(Catalyst& window) {
    // TODO: Port `TwoDifferetViewsWrapper.construct()` (base: Scene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void ImaginaryExponent(Catalyst& window) {
    // TODO: Port `ImaginaryExponent.construct()` (base: ExternallyAnimatedScene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void ComplexEquation(Catalyst& window) {
    // TODO: Port `ComplexEquation.construct()` (base: Scene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void JulietChidingRomeo(Catalyst& window) {
    // TODO: Port `JulietChidingRomeo.construct()` (base: Scene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void General90DegreeRotationExponents(Catalyst& window) {
    // TODO: Port `General90DegreeRotationExponents.construct()` (base: Scene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void RotationIn3dPlane(Catalyst& window) {
    // TODO: Port `RotationIn3dPlane.construct()` (base: Scene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void StoryForAnotherTime(Catalyst& window) {
    // TODO: Port `StoryForAnotherTime.construct()` (base: TeacherStudentsScene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void SchrodingerSum(Catalyst& window) {
    // TODO: Port `SchrodingerSum.construct()` (base: Scene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void BasicVectorFieldIdea(Catalyst& window) {
    // TODO: Port `BasicVectorFieldIdea.construct()` (base: Scene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void NotAllThatRomanticLabel(Catalyst& window) {
    // TODO: Port `NotAllThatRomanticLabel.construct()` (base: Scene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void TransitionWrapper(Catalyst& window) {
    // TODO: Port `TransitionWrapper.construct()` (base: Scene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void DerivativeOfExpMt(Catalyst& window) {
    // TODO: Port `DerivativeOfExpMt.construct()` (base: Scene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void TryIt(Catalyst& window) {
    // TODO: Port `TryIt.construct()` (base: Scene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void TracePropertyAndComputation(Catalyst& window) {
    // TODO: Port `TracePropertyAndComputation.construct()` (base: TeacherStudentsScene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void ExponentialPhaseFlow(Catalyst& window) {
    // TODO: Port `ExponentialPhaseFlow.construct()` (base: Scene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void ExponentialEvaluationWithTime(Catalyst& window) {
    // TODO: Port `ExponentialEvaluationWithTime.construct()` (base: Scene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void FrameForFlow(Catalyst& window) {
    // TODO: Port `FrameForFlow.construct()` (base: Scene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void Thumbnail(Catalyst& window) {
    // TODO: Port `Thumbnail.construct()` (base: Scene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void LetsSumUp(Catalyst& window) {
    // TODO: Port `LetsSumUp.construct()` (base: TeacherStudentsScene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void PrerequisitesWrapper(Catalyst& window) {
    // TODO: Port `PrerequisitesWrapper.construct()` (base: Scene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void SchroedingersComplicatingFactors(Catalyst& window) {
    // TODO: Port `SchroedingersComplicatingFactors.construct()` (base: TeacherStudentsScene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void OldComputationCode(Catalyst& window) {
    // TODO: Port `OldComputationCode.construct()` (base: Scene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void PreviewVisualizationWrapper(Catalyst& window) {
    // TODO: Port `PreviewVisualizationWrapper.construct()` (base: Scene)
    // From: animations/VID/_2022/_2021/matrix_exp.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

struct SceneEntry {
    const char* name;
    void (*fn)(Catalyst&);
};

static constexpr SceneEntry kScenes[] = {
    {"VideoWrapper", &VideoWrapper},
    {"ArnoldBookClip", &ArnoldBookClip},
    {"ZoomInOnProblem", &ZoomInOnProblem},
    {"LeadToPhysicsAndQM", &LeadToPhysicsAndQM},
    {"PlanForThisVideo", &PlanForThisVideo},
    {"IntroduceTheComputation", &IntroduceTheComputation},
    {"WhyTortureMatrices", &WhyTortureMatrices},
    {"DefinitionFirstVsLast", &DefinitionFirstVsLast},
    {"RomeoAndJuliet", &RomeoAndJuliet},
    {"DiscussSystem", &DiscussSystem},
    {"MoreGeneralSystem", &MoreGeneralSystem},
    {"HowExampleLeadsToMatrixExponents", &HowExampleLeadsToMatrixExponents},
    {"From2DTo1D", &From2DTo1D},
    {"SchroedingersEquationIntro", &SchroedingersEquationIntro},
    {"SimpleDerivativeOfExp", &SimpleDerivativeOfExp},
    {"ETitleCard", &ETitleCard},
    {"GraphAndHistoryOfExponential", &GraphAndHistoryOfExponential},
    {"BernoullisThoughts", &BernoullisThoughts},
    {"CompoundInterestPopulationAndEpidemic", &CompoundInterestPopulationAndEpidemic},
    {"CovidPlot", &CovidPlot},
    {"Compare1DTo2DEquations", &Compare1DTo2DEquations},
    {"ManyExponentialForms", &ManyExponentialForms},
    {"EBaseMisconception", &EBaseMisconception},
    {"OneFinalPoint", &OneFinalPoint},
    {"ExoticExponentsWithEBase", &ExoticExponentsWithEBase},
    {"TryToDefineExp", &TryToDefineExp},
    {"SolutionToRomeoJuliet", &SolutionToRomeoJuliet},
    {"RotMatrixStill", &RotMatrixStill},
    {"ExpRotMatrixComputation", &ExpRotMatrixComputation},
    {"ThatsHorrifying", &ThatsHorrifying},
    {"HowBasisVectorMultiplicationPullsOutColumns", &HowBasisVectorMultiplicationPullsOutColumns},
    {"ColumnsToBasisVectors", &ColumnsToBasisVectors},
    {"ReadColumnsOfRotationMatrix", &ReadColumnsOfRotationMatrix},
    {"Show90DegreeRotation", &Show90DegreeRotation},
    {"Show90DegreeRotationColumnByColumn", &Show90DegreeRotationColumnByColumn},
    {"DistanceOverTimeEquation", &DistanceOverTimeEquation},
    {"ExplicitSolution", &ExplicitSolution},
    {"TwoDifferetViewsWrapper", &TwoDifferetViewsWrapper},
    {"ImaginaryExponent", &ImaginaryExponent},
    {"ComplexEquation", &ComplexEquation},
    {"JulietChidingRomeo", &JulietChidingRomeo},
    {"General90DegreeRotationExponents", &General90DegreeRotationExponents},
    {"RotationIn3dPlane", &RotationIn3dPlane},
    {"StoryForAnotherTime", &StoryForAnotherTime},
    {"SchrodingerSum", &SchrodingerSum},
    {"BasicVectorFieldIdea", &BasicVectorFieldIdea},
    {"NotAllThatRomanticLabel", &NotAllThatRomanticLabel},
    {"TransitionWrapper", &TransitionWrapper},
    {"DerivativeOfExpMt", &DerivativeOfExpMt},
    {"TryIt", &TryIt},
    {"TracePropertyAndComputation", &TracePropertyAndComputation},
    {"ExponentialPhaseFlow", &ExponentialPhaseFlow},
    {"ExponentialEvaluationWithTime", &ExponentialEvaluationWithTime},
    {"FrameForFlow", &FrameForFlow},
    {"Thumbnail", &Thumbnail},
    {"LetsSumUp", &LetsSumUp},
    {"PrerequisitesWrapper", &PrerequisitesWrapper},
    {"SchroedingersComplicatingFactors", &SchroedingersComplicatingFactors},
    {"OldComputationCode", &OldComputationCode},
    {"PreviewVisualizationWrapper", &PreviewVisualizationWrapper},
};

int main(int argc, char** argv) {
    Catalyst window(kWidth, kHeight);
    window.setBackground("#000000");
    // window.set3DMode(true);

    const char* chosen = (argc >= 2) ? argv[1] : kScenes[0].name;
    for (const auto& s : kScenes) {
        if (std::strcmp(s.name, chosen) == 0) {
            s.fn(window);
            window.run();
            return 0;
        }
    }

    // Unknown scene name; run the first scene.
    kScenes[0].fn(window);
    window.run();
    return 0;
}
