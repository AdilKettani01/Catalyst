// AUTO-GENERATED Catalyst translation scaffold.
// Source: animations/VID/_2022/_2016/wcat.py
//
// This is a stub port from Manim (Python) to Catalyst (C++).
// Fill in each scene function and replace TODOs with real Catalyst calls.

#include <Catalyst>
#include <cstdint>
#include <cstring>
#include <string_view>

namespace {
constexpr uint32_t kWidth = 1920;
constexpr uint32_t kHeight = 1080;
constexpr float kManimFrameHeight = 8.0f;
constexpr float kManimUnit = static_cast<float>(kHeight) / kManimFrameHeight;  // px per Manim unit

constexpr float X(float manimX) { return static_cast<float>(kWidth) * 0.5f + manimX * kManimUnit; }
constexpr float Y(float manimY) { return static_cast<float>(kHeight) * 0.5f + manimY * kManimUnit; }
}  // namespace

static void ClosedLoopScene(Catalyst& window) {
    // TODO: Port `ClosedLoopScene.construct()` (base: Scene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void Introduction(Catalyst& window) {
    // TODO: Port `Introduction.construct()` (base: TeacherStudentsScene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void WhenIWasAKid(Catalyst& window) {
    // TODO: Port `WhenIWasAKid.construct()` (base: TeacherStudentsScene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void FormingTheMobiusStrip(Catalyst& window) {
    // TODO: Port `FormingTheMobiusStrip.construct()` (base: Scene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void DrawLineOnMobiusStrip(Catalyst& window) {
    // TODO: Port `DrawLineOnMobiusStrip.construct()` (base: Scene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void MugIntoTorus(Catalyst& window) {
    // TODO: Port `MugIntoTorus.construct()` (base: Scene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void DefineInscribedSquareProblem(Catalyst& window) {
    // TODO: Port `DefineInscribedSquareProblem.construct()` (base: ClosedLoopScene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void RectangleProperties(Catalyst& window) {
    // TODO: Port `RectangleProperties.construct()` (base: Scene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void PairOfPairBecomeRectangle(Catalyst& window) {
    // TODO: Port `PairOfPairBecomeRectangle.construct()` (base: Scene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void SearchForRectangleOnLoop(Catalyst& window) {
    // TODO: Port `SearchForRectangleOnLoop.construct()` (base: ClosedLoopScene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void DeclareFunction(Catalyst& window) {
    // TODO: Port `DeclareFunction.construct()` (base: ClosedLoopScene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void DefinePairTo3dFunction(Catalyst& window) {
    // TODO: Port `DefinePairTo3dFunction.construct()` (base: Scene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void LabelMidpoint(Catalyst& window) {
    // TODO: Port `LabelMidpoint.construct()` (base: Scene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void LabelDistance(Catalyst& window) {
    // TODO: Port `LabelDistance.construct()` (base: Scene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void DrawingOneLineOfTheSurface(Catalyst& window) {
    // TODO: Port `DrawingOneLineOfTheSurface.construct()` (base: Scene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void FunctionSurface(Catalyst& window) {
    // TODO: Port `FunctionSurface.construct()` (base: Scene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void PointPairApprocahingEachother3D(Catalyst& window) {
    // TODO: Port `PointPairApprocahingEachother3D.construct()` (base: Scene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void InputPairToFunction(Catalyst& window) {
    // TODO: Port `InputPairToFunction.construct()` (base: Scene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void WigglePairUnderSurface(Catalyst& window) {
    // TODO: Port `WigglePairUnderSurface.construct()` (base: Scene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void WriteContinuous(Catalyst& window) {
    // TODO: Port `WriteContinuous.construct()` (base: Scene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void DistinctPairCollisionOnSurface(Catalyst& window) {
    // TODO: Port `DistinctPairCollisionOnSurface.construct()` (base: Scene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void PairsOfPointsOnLoop(Catalyst& window) {
    // TODO: Port `PairsOfPointsOnLoop.construct()` (base: ClosedLoopScene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void PairOfRealsToPlane(Catalyst& window) {
    // TODO: Port `PairOfRealsToPlane.construct()` (base: Scene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void SeekSurfaceForPairs(Catalyst& window) {
    // TODO: Port `SeekSurfaceForPairs.construct()` (base: ClosedLoopScene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void AskAbouPairType(Catalyst& window) {
    // TODO: Port `AskAbouPairType.construct()` (base: TeacherStudentsScene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void DefineOrderedPair(Catalyst& window) {
    // TODO: Port `DefineOrderedPair.construct()` (base: ClosedLoopScene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void DefineUnorderedPair(Catalyst& window) {
    // TODO: Port `DefineUnorderedPair.construct()` (base: ClosedLoopScene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void BeginWithOrdered(Catalyst& window) {
    // TODO: Port `BeginWithOrdered.construct()` (base: TeacherStudentsScene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void DeformToInterval(Catalyst& window) {
    // TODO: Port `DeformToInterval.construct()` (base: ClosedLoopScene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void RepresentPairInUnitSquare(Catalyst& window) {
    // TODO: Port `RepresentPairInUnitSquare.construct()` (base: ClosedLoopScene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void EdgesOfSquare(Catalyst& window) {
    // TODO: Port `EdgesOfSquare.construct()` (base: Scene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void EndpointsGluedTogether(Catalyst& window) {
    // TODO: Port `EndpointsGluedTogether.construct()` (base: ClosedLoopScene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void WrapUpToTorus(Catalyst& window) {
    // TODO: Port `WrapUpToTorus.construct()` (base: Scene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void TorusPlaneAnalogy(Catalyst& window) {
    // TODO: Port `TorusPlaneAnalogy.construct()` (base: ClosedLoopScene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void WigglingPairOfPoints(Catalyst& window) {
    // TODO: Port `WigglingPairOfPoints.construct()` (base: ClosedLoopScene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void WigglingTorusPoint(Catalyst& window) {
    // TODO: Port `WigglingTorusPoint.construct()` (base: Scene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void WhatAboutUnordered(Catalyst& window) {
    // TODO: Port `WhatAboutUnordered.construct()` (base: TeacherStudentsScene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void TrivialPairCollision(Catalyst& window) {
    // TODO: Port `TrivialPairCollision.construct()` (base: ClosedLoopScene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void NotHelpful(Catalyst& window) {
    // TODO: Port `NotHelpful.construct()` (base: Scene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void PrepareForMobiusStrip(Catalyst& window) {
    // TODO: Port `PrepareForMobiusStrip.construct()` (base: Scene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void FoldToMobius(Catalyst& window) {
    // TODO: Port `FoldToMobius.construct()` (base: Scene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void MobiusPlaneAnalogy(Catalyst& window) {
    // TODO: Port `MobiusPlaneAnalogy.construct()` (base: ClosedLoopScene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void DrawRightArrow(Catalyst& window) {
    // TODO: Port `DrawRightArrow.construct()` (base: Scene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void MobiusToPairToSurface(Catalyst& window) {
    // TODO: Port `MobiusToPairToSurface.construct()` (base: ClosedLoopScene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void MapMobiusStripOntoSurface(Catalyst& window) {
    // TODO: Port `MapMobiusStripOntoSurface.construct()` (base: Scene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void StripMustIntersectItself(Catalyst& window) {
    // TODO: Port `StripMustIntersectItself.construct()` (base: TeacherStudentsScene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void PairOfMobiusPointsLandOnEachother(Catalyst& window) {
    // TODO: Port `PairOfMobiusPointsLandOnEachother.construct()` (base: Scene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void ThatsTheProof(Catalyst& window) {
    // TODO: Port `ThatsTheProof.construct()` (base: TeacherStudentsScene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void TryItYourself(Catalyst& window) {
    // TODO: Port `TryItYourself.construct()` (base: TeacherStudentsScene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void OneMoreAnimation(Catalyst& window) {
    // TODO: Port `OneMoreAnimation.construct()` (base: TeacherStudentsScene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void PatreonThanks(Catalyst& window) {
    // TODO: Port `PatreonThanks.construct()` (base: Scene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void CreditTWo(Catalyst& window) {
    // TODO: Port `CreditTWo.construct()` (base: Scene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void CreditThree(Catalyst& window) {
    // TODO: Port `CreditThree.construct()` (base: Scene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void ShiftingLoopPairSurface(Catalyst& window) {
    // TODO: Port `ShiftingLoopPairSurface.construct()` (base: Scene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void ThumbnailImage(Catalyst& window) {
    // TODO: Port `ThumbnailImage.construct()` (base: ClosedLoopScene)
    // From: animations/VID/_2022/_2016/wcat.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

struct SceneEntry {
    const char* name;
    void (*fn)(Catalyst&);
};

static constexpr SceneEntry kScenes[] = {
    {"ClosedLoopScene", &ClosedLoopScene},
    {"Introduction", &Introduction},
    {"WhenIWasAKid", &WhenIWasAKid},
    {"FormingTheMobiusStrip", &FormingTheMobiusStrip},
    {"DrawLineOnMobiusStrip", &DrawLineOnMobiusStrip},
    {"MugIntoTorus", &MugIntoTorus},
    {"DefineInscribedSquareProblem", &DefineInscribedSquareProblem},
    {"RectangleProperties", &RectangleProperties},
    {"PairOfPairBecomeRectangle", &PairOfPairBecomeRectangle},
    {"SearchForRectangleOnLoop", &SearchForRectangleOnLoop},
    {"DeclareFunction", &DeclareFunction},
    {"DefinePairTo3dFunction", &DefinePairTo3dFunction},
    {"LabelMidpoint", &LabelMidpoint},
    {"LabelDistance", &LabelDistance},
    {"DrawingOneLineOfTheSurface", &DrawingOneLineOfTheSurface},
    {"FunctionSurface", &FunctionSurface},
    {"PointPairApprocahingEachother3D", &PointPairApprocahingEachother3D},
    {"InputPairToFunction", &InputPairToFunction},
    {"WigglePairUnderSurface", &WigglePairUnderSurface},
    {"WriteContinuous", &WriteContinuous},
    {"DistinctPairCollisionOnSurface", &DistinctPairCollisionOnSurface},
    {"PairsOfPointsOnLoop", &PairsOfPointsOnLoop},
    {"PairOfRealsToPlane", &PairOfRealsToPlane},
    {"SeekSurfaceForPairs", &SeekSurfaceForPairs},
    {"AskAbouPairType", &AskAbouPairType},
    {"DefineOrderedPair", &DefineOrderedPair},
    {"DefineUnorderedPair", &DefineUnorderedPair},
    {"BeginWithOrdered", &BeginWithOrdered},
    {"DeformToInterval", &DeformToInterval},
    {"RepresentPairInUnitSquare", &RepresentPairInUnitSquare},
    {"EdgesOfSquare", &EdgesOfSquare},
    {"EndpointsGluedTogether", &EndpointsGluedTogether},
    {"WrapUpToTorus", &WrapUpToTorus},
    {"TorusPlaneAnalogy", &TorusPlaneAnalogy},
    {"WigglingPairOfPoints", &WigglingPairOfPoints},
    {"WigglingTorusPoint", &WigglingTorusPoint},
    {"WhatAboutUnordered", &WhatAboutUnordered},
    {"TrivialPairCollision", &TrivialPairCollision},
    {"NotHelpful", &NotHelpful},
    {"PrepareForMobiusStrip", &PrepareForMobiusStrip},
    {"FoldToMobius", &FoldToMobius},
    {"MobiusPlaneAnalogy", &MobiusPlaneAnalogy},
    {"DrawRightArrow", &DrawRightArrow},
    {"MobiusToPairToSurface", &MobiusToPairToSurface},
    {"MapMobiusStripOntoSurface", &MapMobiusStripOntoSurface},
    {"StripMustIntersectItself", &StripMustIntersectItself},
    {"PairOfMobiusPointsLandOnEachother", &PairOfMobiusPointsLandOnEachother},
    {"ThatsTheProof", &ThatsTheProof},
    {"TryItYourself", &TryItYourself},
    {"OneMoreAnimation", &OneMoreAnimation},
    {"PatreonThanks", &PatreonThanks},
    {"CreditTWo", &CreditTWo},
    {"CreditThree", &CreditThree},
    {"ShiftingLoopPairSurface", &ShiftingLoopPairSurface},
    {"ThumbnailImage", &ThumbnailImage},
};

int main(int argc, char** argv) {
    Catalyst window(kWidth, kHeight);
    window.setBackground("#000000");
    // window.set3DMode(true);

    const char* chosen = (argc >= 2) ? argv[1] : kScenes[0].name;
    for (const auto& s : kScenes) {
        if (std::strcmp(s.name, chosen) == 0) {
            s.fn(window);
            window.run();
            return 0;
        }
    }

    // Unknown scene name; run the first scene.
    kScenes[0].fn(window);
    window.run();
    return 0;
}
