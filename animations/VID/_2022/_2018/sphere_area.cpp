// AUTO-GENERATED Catalyst translation scaffold.
// Source: animations/VID/_2022/_2018/sphere_area.py
//
// This is a stub port from Manim (Python) to Catalyst (C++).
// Fill in each scene function and replace TODOs with real Catalyst calls.

#include <Catalyst>
#include <cstdint>
#include <cstring>
#include <string_view>

namespace {
constexpr uint32_t kWidth = 1920;
constexpr uint32_t kHeight = 1080;
constexpr float kManimFrameHeight = 8.0f;
constexpr float kManimUnit = static_cast<float>(kHeight) / kManimFrameHeight;  // px per Manim unit

constexpr float X(float manimX) { return static_cast<float>(kWidth) * 0.5f + manimX * kManimUnit; }
constexpr float Y(float manimY) { return static_cast<float>(kHeight) * 0.5f + manimY * kManimUnit; }
}  // namespace

static void SphereCylinderScene(Catalyst& window) {
    // TODO: Port `SphereCylinderScene.construct()` (base: SpecialThreeDScene)
    // From: animations/VID/_2022/_2018/sphere_area.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void AskAboutShadowRelation(Catalyst& window) {
    // TODO: Port `AskAboutShadowRelation.construct()` (base: SpecialThreeDScene)
    // From: animations/VID/_2022/_2018/sphere_area.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void ButWhy(Catalyst& window) {
    // TODO: Port `ButWhy.construct()` (base: TeacherStudentsScene)
    // From: animations/VID/_2022/_2018/sphere_area.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void TryFittingCirclesDirectly(Catalyst& window) {
    // TODO: Port `TryFittingCirclesDirectly.construct()` (base: ExternallyAnimatedScene)
    // From: animations/VID/_2022/_2018/sphere_area.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void PreviewTwoMethods(Catalyst& window) {
    // TODO: Port `PreviewTwoMethods.construct()` (base: MovingCameraScene)
    // From: animations/VID/_2022/_2018/sphere_area.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void MapSphereOntoCylinder(Catalyst& window) {
    // TODO: Port `MapSphereOntoCylinder.construct()` (base: SphereCylinderScene)
    // From: animations/VID/_2022/_2018/sphere_area.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void CircumferenceOfCylinder(Catalyst& window) {
    // TODO: Port `CircumferenceOfCylinder.construct()` (base: SphereCylinderScene)
    // From: animations/VID/_2022/_2018/sphere_area.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void UnfoldCircles(Catalyst& window) {
    // TODO: Port `UnfoldCircles.construct()` (base: Scene)
    // From: animations/VID/_2022/_2018/sphere_area.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void ShowProjection(Catalyst& window) {
    // TODO: Port `ShowProjection.construct()` (base: SphereCylinderScene)
    // From: animations/VID/_2022/_2018/sphere_area.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void ProTipNameThings(Catalyst& window) {
    // TODO: Port `ProTipNameThings.construct()` (base: Scene)
    // From: animations/VID/_2022/_2018/sphere_area.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void WidthScaleLabel(Catalyst& window) {
    // TODO: Port `WidthScaleLabel.construct()` (base: Scene)
    // From: animations/VID/_2022/_2018/sphere_area.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void HeightSquishLabel(Catalyst& window) {
    // TODO: Port `HeightSquishLabel.construct()` (base: Scene)
    // From: animations/VID/_2022/_2018/sphere_area.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void TinierAndTinerRectangles(Catalyst& window) {
    // TODO: Port `TinierAndTinerRectangles.construct()` (base: SphereCylinderScene)
    // From: animations/VID/_2022/_2018/sphere_area.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void JustifyHeightSquish(Catalyst& window) {
    // TODO: Port `JustifyHeightSquish.construct()` (base: MovingCameraScene)
    // From: animations/VID/_2022/_2018/sphere_area.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void DrawSquareThenFade(Catalyst& window) {
    // TODO: Port `DrawSquareThenFade.construct()` (base: Scene)
    // From: animations/VID/_2022/_2018/sphere_area.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void WhyAreWeDoingThis(Catalyst& window) {
    // TODO: Port `WhyAreWeDoingThis.construct()` (base: TeacherStudentsScene)
    // From: animations/VID/_2022/_2018/sphere_area.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void SameEffectAsRotating(Catalyst& window) {
    // TODO: Port `SameEffectAsRotating.construct()` (base: Scene)
    // From: animations/VID/_2022/_2018/sphere_area.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void ShowParameterization(Catalyst& window) {
    // TODO: Port `ShowParameterization.construct()` (base: Scene)
    // From: animations/VID/_2022/_2018/sphere_area.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void RdLabels(Catalyst& window) {
    // TODO: Port `RdLabels.construct()` (base: Scene)
    // From: animations/VID/_2022/_2018/sphere_area.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void ThinkingCritically(Catalyst& window) {
    // TODO: Port `ThinkingCritically.construct()` (base: PiCreatureScene)
    // From: animations/VID/_2022/_2018/sphere_area.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void WriteNotEquals(Catalyst& window) {
    // TODO: Port `WriteNotEquals.construct()` (base: Scene)
    // From: animations/VID/_2022/_2018/sphere_area.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void RectangulatedSphere(Catalyst& window) {
    // TODO: Port `RectangulatedSphere.construct()` (base: SphereCylinderScene)
    // From: animations/VID/_2022/_2018/sphere_area.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void SequenceOfSpheres(Catalyst& window) {
    // TODO: Port `SequenceOfSpheres.construct()` (base: SphereCylinderScene)
    // From: animations/VID/_2022/_2018/sphere_area.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void WhatIsSurfaceArea(Catalyst& window) {
    // TODO: Port `WhatIsSurfaceArea.construct()` (base: SpecialThreeDScene)
    // From: animations/VID/_2022/_2018/sphere_area.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void EoCWrapper(Catalyst& window) {
    // TODO: Port `EoCWrapper.construct()` (base: Scene)
    // From: animations/VID/_2022/_2018/sphere_area.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void RoleOfCalculus(Catalyst& window) {
    // TODO: Port `RoleOfCalculus.construct()` (base: SpecialThreeDScene)
    // From: animations/VID/_2022/_2018/sphere_area.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void AskAboutDirectConnection(Catalyst& window) {
    // TODO: Port `AskAboutDirectConnection.construct()` (base: TeacherStudentsScene)
    // From: animations/VID/_2022/_2018/sphere_area.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void ExercisesGiveLearning(Catalyst& window) {
    // TODO: Port `ExercisesGiveLearning.construct()` (base: MovingCameraScene)
    // From: animations/VID/_2022/_2018/sphere_area.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void NobodyLikesHomework(Catalyst& window) {
    // TODO: Port `NobodyLikesHomework.construct()` (base: TeacherStudentsScene)
    // From: animations/VID/_2022/_2018/sphere_area.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void ChallengeMode(Catalyst& window) {
    // TODO: Port `ChallengeMode.construct()` (base: Scene)
    // From: animations/VID/_2022/_2018/sphere_area.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void SecondProof(Catalyst& window) {
    // TODO: Port `SecondProof.construct()` (base: SpecialThreeDScene)
    // From: animations/VID/_2022/_2018/sphere_area.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void RangeFrom0To180(Catalyst& window) {
    // TODO: Port `RangeFrom0To180.construct()` (base: Scene)
    // From: animations/VID/_2022/_2018/sphere_area.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void Question1(Catalyst& window) {
    // TODO: Port `Question1.construct()` (base: Scene)
    // From: animations/VID/_2022/_2018/sphere_area.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void YouCouldIntegrate(Catalyst& window) {
    // TODO: Port `YouCouldIntegrate.construct()` (base: TeacherStudentsScene)
    // From: animations/VID/_2022/_2018/sphere_area.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void Question2(Catalyst& window) {
    // TODO: Port `Question2.construct()` (base: Scene)
    // From: animations/VID/_2022/_2018/sphere_area.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void Question3(Catalyst& window) {
    // TODO: Port `Question3.construct()` (base: Scene)
    // From: animations/VID/_2022/_2018/sphere_area.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void ExtraHint(Catalyst& window) {
    // TODO: Port `ExtraHint.construct()` (base: Scene)
    // From: animations/VID/_2022/_2018/sphere_area.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void Question4(Catalyst& window) {
    // TODO: Port `Question4.construct()` (base: Scene)
    // From: animations/VID/_2022/_2018/sphere_area.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void Question5(Catalyst& window) {
    // TODO: Port `Question5.construct()` (base: Scene)
    // From: animations/VID/_2022/_2018/sphere_area.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void SpherePatronThanks(Catalyst& window) {
    // TODO: Port `SpherePatronThanks.construct()` (base: Scene)
    // From: animations/VID/_2022/_2018/sphere_area.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void ForThoseStillAround(Catalyst& window) {
    // TODO: Port `ForThoseStillAround.construct()` (base: Scene)
    // From: animations/VID/_2022/_2018/sphere_area.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void PatronWords(Catalyst& window) {
    // TODO: Port `PatronWords.construct()` (base: Scene)
    // From: animations/VID/_2022/_2018/sphere_area.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void PlushMe(Catalyst& window) {
    // TODO: Port `PlushMe.construct()` (base: TeacherStudentsScene)
    // From: animations/VID/_2022/_2018/sphere_area.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

static void Thumbnail(Catalyst& window) {
    // TODO: Port `Thumbnail.construct()` (base: SpecialThreeDScene)
    // From: animations/VID/_2022/_2018/sphere_area.py
    // NOTE: Source appears to use 3D constructs; you may need `window.set3DMode(true)` and camera controls.
    (void)window;
}

struct SceneEntry {
    const char* name;
    void (*fn)(Catalyst&);
};

static constexpr SceneEntry kScenes[] = {
    {"SphereCylinderScene", &SphereCylinderScene},
    {"AskAboutShadowRelation", &AskAboutShadowRelation},
    {"ButWhy", &ButWhy},
    {"TryFittingCirclesDirectly", &TryFittingCirclesDirectly},
    {"PreviewTwoMethods", &PreviewTwoMethods},
    {"MapSphereOntoCylinder", &MapSphereOntoCylinder},
    {"CircumferenceOfCylinder", &CircumferenceOfCylinder},
    {"UnfoldCircles", &UnfoldCircles},
    {"ShowProjection", &ShowProjection},
    {"ProTipNameThings", &ProTipNameThings},
    {"WidthScaleLabel", &WidthScaleLabel},
    {"HeightSquishLabel", &HeightSquishLabel},
    {"TinierAndTinerRectangles", &TinierAndTinerRectangles},
    {"JustifyHeightSquish", &JustifyHeightSquish},
    {"DrawSquareThenFade", &DrawSquareThenFade},
    {"WhyAreWeDoingThis", &WhyAreWeDoingThis},
    {"SameEffectAsRotating", &SameEffectAsRotating},
    {"ShowParameterization", &ShowParameterization},
    {"RdLabels", &RdLabels},
    {"ThinkingCritically", &ThinkingCritically},
    {"WriteNotEquals", &WriteNotEquals},
    {"RectangulatedSphere", &RectangulatedSphere},
    {"SequenceOfSpheres", &SequenceOfSpheres},
    {"WhatIsSurfaceArea", &WhatIsSurfaceArea},
    {"EoCWrapper", &EoCWrapper},
    {"RoleOfCalculus", &RoleOfCalculus},
    {"AskAboutDirectConnection", &AskAboutDirectConnection},
    {"ExercisesGiveLearning", &ExercisesGiveLearning},
    {"NobodyLikesHomework", &NobodyLikesHomework},
    {"ChallengeMode", &ChallengeMode},
    {"SecondProof", &SecondProof},
    {"RangeFrom0To180", &RangeFrom0To180},
    {"Question1", &Question1},
    {"YouCouldIntegrate", &YouCouldIntegrate},
    {"Question2", &Question2},
    {"Question3", &Question3},
    {"ExtraHint", &ExtraHint},
    {"Question4", &Question4},
    {"Question5", &Question5},
    {"SpherePatronThanks", &SpherePatronThanks},
    {"ForThoseStillAround", &ForThoseStillAround},
    {"PatronWords", &PatronWords},
    {"PlushMe", &PlushMe},
    {"Thumbnail", &Thumbnail},
};

int main(int argc, char** argv) {
    Catalyst window(kWidth, kHeight);
    window.setBackground("#000000");
    // window.set3DMode(true);

    const char* chosen = (argc >= 2) ? argv[1] : kScenes[0].name;
    for (const auto& s : kScenes) {
        if (std::strcmp(s.name, chosen) == 0) {
            s.fn(window);
            window.run();
            return 0;
        }
    }

    // Unknown scene name; run the first scene.
    kScenes[0].fn(window);
    window.run();
    return 0;
}
