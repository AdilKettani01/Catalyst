// AUTO-GENERATED Catalyst translation scaffold.
// Source: animations/VID/_2022/_2018/dandelin.py
//
// This is a stub port from Manim (Python) to Catalyst (C++).
// Fill in each scene function and replace TODOs with real Catalyst calls.

#include <Catalyst>
#include <cstdint>
#include <cstring>
#include <string_view>

namespace {
constexpr uint32_t kWidth = 1920;
constexpr uint32_t kHeight = 1080;
constexpr float kManimFrameHeight = 8.0f;
constexpr float kManimUnit = static_cast<float>(kHeight) / kManimFrameHeight;  // px per Manim unit

constexpr float X(float manimX) { return static_cast<float>(kWidth) * 0.5f + manimX * kManimUnit; }
constexpr float Y(float manimY) { return static_cast<float>(kHeight) * 0.5f + manimY * kManimUnit; }
}  // namespace

static void ThinkingAboutAProof(Catalyst& window) {
    // TODO: Port `ThinkingAboutAProof.construct()` (base: PiCreatureScene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void SumOfIntegersProof(Catalyst& window) {
    // TODO: Port `SumOfIntegersProof.construct()` (base: Scene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void FeynmansLostLectureWrapper(Catalyst& window) {
    // TODO: Port `FeynmansLostLectureWrapper.construct()` (base: Scene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void HoldUpProof(Catalyst& window) {
    // TODO: Port `HoldUpProof.construct()` (base: TeacherStudentsScene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void MultipleDefinitionsOfAnEllipse(Catalyst& window) {
    // TODO: Port `MultipleDefinitionsOfAnEllipse.construct()` (base: Scene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void StretchACircle(Catalyst& window) {
    // TODO: Port `StretchACircle.construct()` (base: Scene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void ShowArrayOfEccentricities(Catalyst& window) {
    // TODO: Port `ShowArrayOfEccentricities.construct()` (base: Scene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void EccentricityForSlicedConed(Catalyst& window) {
    // TODO: Port `EccentricityForSlicedConed.construct()` (base: Scene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void AskWhyAreTheyTheSame(Catalyst& window) {
    // TODO: Port `AskWhyAreTheyTheSame.construct()` (base: TeacherStudentsScene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void TriangleOfEquivalences(Catalyst& window) {
    // TODO: Port `TriangleOfEquivalences.construct()` (base: Scene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void SliceCone(Catalyst& window) {
    // TODO: Port `SliceCone.construct()` (base: ExternallyAnimatedScene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void TiltPlane(Catalyst& window) {
    // TODO: Port `TiltPlane.construct()` (base: ExternallyAnimatedScene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void IntroduceConeEllipseFocalSum(Catalyst& window) {
    // TODO: Port `IntroduceConeEllipseFocalSum.construct()` (base: ExternallyAnimatedScene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void ShowMeasurementBook(Catalyst& window) {
    // TODO: Port `ShowMeasurementBook.construct()` (base: TeacherStudentsScene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void IntroduceSpheres(Catalyst& window) {
    // TODO: Port `IntroduceSpheres.construct()` (base: ExternallyAnimatedScene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void TangencyAnimation(Catalyst& window) {
    // TODO: Port `TangencyAnimation.construct()` (base: Scene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void TwoSpheresRotating(Catalyst& window) {
    // TODO: Port `TwoSpheresRotating.construct()` (base: ExternallyAnimatedScene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void TiltSlopeWithOnlySpheres(Catalyst& window) {
    // TODO: Port `TiltSlopeWithOnlySpheres.construct()` (base: ExternallyAnimatedScene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void TiltSlopeWithOnlySpheresSideView(Catalyst& window) {
    // TODO: Port `TiltSlopeWithOnlySpheresSideView.construct()` (base: ExternallyAnimatedScene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void AskAboutWhyYouWouldAddSpheres(Catalyst& window) {
    // TODO: Port `AskAboutWhyYouWouldAddSpheres.construct()` (base: PiCreatureScene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void ShowTangencyPoints(Catalyst& window) {
    // TODO: Port `ShowTangencyPoints.construct()` (base: ExternallyAnimatedScene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void ShowFocalLinesAsTangent(Catalyst& window) {
    // TODO: Port `ShowFocalLinesAsTangent.construct()` (base: ExternallyAnimatedScene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void UseDefiningFeatures(Catalyst& window) {
    // TODO: Port `UseDefiningFeatures.construct()` (base: Scene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void RemindAboutTangencyToCone(Catalyst& window) {
    // TODO: Port `RemindAboutTangencyToCone.construct()` (base: ExternallyAnimatedScene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void ShowCircleToCircleLine(Catalyst& window) {
    // TODO: Port `ShowCircleToCircleLine.construct()` (base: ExternallyAnimatedScene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void ShowSegmentSplit(Catalyst& window) {
    // TODO: Port `ShowSegmentSplit.construct()` (base: Scene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void ShowCircleToCircleLineAtMultiplePoints(Catalyst& window) {
    // TODO: Port `ShowCircleToCircleLineAtMultiplePoints.construct()` (base: ExternallyAnimatedScene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void ConjectureLineEquivalence(Catalyst& window) {
    // TODO: Port `ConjectureLineEquivalence.construct()` (base: ExternallyAnimatedScene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void WriteConjecture(Catalyst& window) {
    // TODO: Port `WriteConjecture.construct()` (base: Scene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void ShowQ(Catalyst& window) {
    // TODO: Port `ShowQ.construct()` (base: Scene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void ShowBigSphereTangentLines(Catalyst& window) {
    // TODO: Port `ShowBigSphereTangentLines.construct()` (base: ExternallyAnimatedScene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void LinesTangentToSphere(Catalyst& window) {
    // TODO: Port `LinesTangentToSphere.construct()` (base: ExternallyAnimatedScene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void QuickGeometryProof(Catalyst& window) {
    // TODO: Port `QuickGeometryProof.construct()` (base: Scene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void ShowFocalSumEqualsCircleDistance(Catalyst& window) {
    // TODO: Port `ShowFocalSumEqualsCircleDistance.construct()` (base: ExternallyAnimatedScene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void FinalMovingEllipsePoint(Catalyst& window) {
    // TODO: Port `FinalMovingEllipsePoint.construct()` (base: ExternallyAnimatedScene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void TiltPlaneWithSpheres(Catalyst& window) {
    // TODO: Port `TiltPlaneWithSpheres.construct()` (base: ExternallyAnimatedScene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void NameDandelin(Catalyst& window) {
    // TODO: Port `NameDandelin.construct()` (base: Scene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void DandelinSpheresInCylinder(Catalyst& window) {
    // TODO: Port `DandelinSpheresInCylinder.construct()` (base: ExternallyAnimatedScene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void ProjectCircleOntoTiltedPlane(Catalyst& window) {
    // TODO: Port `ProjectCircleOntoTiltedPlane.construct()` (base: ExternallyAnimatedScene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void CylinderDandelinSpheresChangingSlope(Catalyst& window) {
    // TODO: Port `CylinderDandelinSpheresChangingSlope.construct()` (base: ExternallyAnimatedScene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void DetailsLeftAsHomework(Catalyst& window) {
    // TODO: Port `DetailsLeftAsHomework.construct()` (base: PiCreatureScene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void AskWhyYouWouldChooseThisProof(Catalyst& window) {
    // TODO: Port `AskWhyYouWouldChooseThisProof.construct()` (base: PiCreatureScene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void CreativeConstruction(Catalyst& window) {
    // TODO: Port `CreativeConstruction.construct()` (base: PiCreatureScene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void LockhartQuote(Catalyst& window) {
    // TODO: Port `LockhartQuote.construct()` (base: Scene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void ImmersedInGeometryProblems(Catalyst& window) {
    // TODO: Port `ImmersedInGeometryProblems.construct()` (base: PiCreatureScene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void ShowApollonianCircles(Catalyst& window) {
    // TODO: Port `ShowApollonianCircles.construct()` (base: Scene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

static void ReactionToGlimpseOfGenius(Catalyst& window) {
    // TODO: Port `ReactionToGlimpseOfGenius.construct()` (base: TeacherStudentsScene)
    // From: animations/VID/_2022/_2018/dandelin.py
    (void)window;
}

struct SceneEntry {
    const char* name;
    void (*fn)(Catalyst&);
};

static constexpr SceneEntry kScenes[] = {
    {"ThinkingAboutAProof", &ThinkingAboutAProof},
    {"SumOfIntegersProof", &SumOfIntegersProof},
    {"FeynmansLostLectureWrapper", &FeynmansLostLectureWrapper},
    {"HoldUpProof", &HoldUpProof},
    {"MultipleDefinitionsOfAnEllipse", &MultipleDefinitionsOfAnEllipse},
    {"StretchACircle", &StretchACircle},
    {"ShowArrayOfEccentricities", &ShowArrayOfEccentricities},
    {"EccentricityForSlicedConed", &EccentricityForSlicedConed},
    {"AskWhyAreTheyTheSame", &AskWhyAreTheyTheSame},
    {"TriangleOfEquivalences", &TriangleOfEquivalences},
    {"SliceCone", &SliceCone},
    {"TiltPlane", &TiltPlane},
    {"IntroduceConeEllipseFocalSum", &IntroduceConeEllipseFocalSum},
    {"ShowMeasurementBook", &ShowMeasurementBook},
    {"IntroduceSpheres", &IntroduceSpheres},
    {"TangencyAnimation", &TangencyAnimation},
    {"TwoSpheresRotating", &TwoSpheresRotating},
    {"TiltSlopeWithOnlySpheres", &TiltSlopeWithOnlySpheres},
    {"TiltSlopeWithOnlySpheresSideView", &TiltSlopeWithOnlySpheresSideView},
    {"AskAboutWhyYouWouldAddSpheres", &AskAboutWhyYouWouldAddSpheres},
    {"ShowTangencyPoints", &ShowTangencyPoints},
    {"ShowFocalLinesAsTangent", &ShowFocalLinesAsTangent},
    {"UseDefiningFeatures", &UseDefiningFeatures},
    {"RemindAboutTangencyToCone", &RemindAboutTangencyToCone},
    {"ShowCircleToCircleLine", &ShowCircleToCircleLine},
    {"ShowSegmentSplit", &ShowSegmentSplit},
    {"ShowCircleToCircleLineAtMultiplePoints", &ShowCircleToCircleLineAtMultiplePoints},
    {"ConjectureLineEquivalence", &ConjectureLineEquivalence},
    {"WriteConjecture", &WriteConjecture},
    {"ShowQ", &ShowQ},
    {"ShowBigSphereTangentLines", &ShowBigSphereTangentLines},
    {"LinesTangentToSphere", &LinesTangentToSphere},
    {"QuickGeometryProof", &QuickGeometryProof},
    {"ShowFocalSumEqualsCircleDistance", &ShowFocalSumEqualsCircleDistance},
    {"FinalMovingEllipsePoint", &FinalMovingEllipsePoint},
    {"TiltPlaneWithSpheres", &TiltPlaneWithSpheres},
    {"NameDandelin", &NameDandelin},
    {"DandelinSpheresInCylinder", &DandelinSpheresInCylinder},
    {"ProjectCircleOntoTiltedPlane", &ProjectCircleOntoTiltedPlane},
    {"CylinderDandelinSpheresChangingSlope", &CylinderDandelinSpheresChangingSlope},
    {"DetailsLeftAsHomework", &DetailsLeftAsHomework},
    {"AskWhyYouWouldChooseThisProof", &AskWhyYouWouldChooseThisProof},
    {"CreativeConstruction", &CreativeConstruction},
    {"LockhartQuote", &LockhartQuote},
    {"ImmersedInGeometryProblems", &ImmersedInGeometryProblems},
    {"ShowApollonianCircles", &ShowApollonianCircles},
    {"ReactionToGlimpseOfGenius", &ReactionToGlimpseOfGenius},
};

int main(int argc, char** argv) {
    Catalyst window(kWidth, kHeight);
    window.setBackground("#000000");

    const char* chosen = (argc >= 2) ? argv[1] : kScenes[0].name;
    for (const auto& s : kScenes) {
        if (std::strcmp(s.name, chosen) == 0) {
            s.fn(window);
            window.run();
            return 0;
        }
    }

    // Unknown scene name; run the first scene.
    kScenes[0].fn(window);
    window.run();
    return 0;
}
